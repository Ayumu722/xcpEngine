warpspace() {
   local a_chk a_edges d_chk d_edges e edges f_chk f_edges i k layer n node_chk nodes o objects output route source t target x xfm
   ################################################################
   # Parse inputs
   # i         Image to be warped
   # o         Output path for warped image
   # n         Interpolation scheme
   # target    Target space to warp to
   ################################################################
   i=${1}
   o=${2}
   target=${3}
   [[ -n ${4} ]] && n="-n ${4}"
   ################################################################
   # Determine the coordinate space of origin
   ################################################################
   if [[ ${i} == ${img} ]]
      then
      source=${space}
   elif contains ${i} "atlas:"
      then
      i=${i//atlas:/}
      source=$(   json_query  ${i}  Space    "${atlas[${subjidx}]}")
      i=$(        json_query  ${i}  Map      "${atlas[${subjidx}]}")
   else
      source=$(   json_query  ${i}  Space    "${aux_imgs[${subjidx}]}")
      i=$(        json_query  ${i}  Map      "${aux_imgs[${subjidx}]}")
   fi
   i=$(eval echo ${i})
   ################################################################
   # Parse available spaces (nodes) and transforms (edges)
   ################################################################
   objects=$(cat  ${spaces}   |$JQ_PATH      'keys[]')
   for k    in    $objects
      do
      node_chk=$( json_query  ${k}  Map               ${spaces})
      if [[       -n ${node_chk} ]]
         then
         k=${k//\%*/}
         nodes="${nodes} ${k//\"/}"
      else
         edges="${edges} ${k//\"/}"
         a_chk=$( json_query  ${k}  TransformANTs     ${spaces})
         f_chk=$( json_query  ${k}  TransformFSL      ${spaces})
         d_chk=$( json_query  ${k}  TransformDRAMMS   ${spaces})
         if [[    -n ${a_chk}    ]]
            then
            a_edges="${a_edges} ${k//\"/}"
         fi
         if [[    -n ${f_chk}    ]]
            then
            f_edges="${a_edges} ${k//\"/}"
         fi
         if [[    -n ${d_chk}    ]]
            then
            d_edges="${a_edges} ${k//\"/}"
         fi
      fi
   done
   ################################################################
   # Determine the shortest route from the source space to the
   # target space
   ################################################################
   nodes=$(echo $nodes)
   edges=$(echo $edges)
   nodes=${nodes// /,}
   edges=${edges// /,}
   route=( $(${XCPEDIR}/utils/warprouter.R \
      -n ${nodes} \
      -e ${edges} \
      -s ${source} \
      -t ${target//\%*/}) )
   ################################################################
   # Obtain the target reference and perform the warp
   ################################################################
   target=$(json_query \"${target}\" Map ${spaces})
   target=$(eval echo ${target})
   layer=${route[0]}
   route=( "${route[@]:1}" )
   for e in "${route[@]}"
      do
      t=$(json_query \"${e}\" TransformANTs ${spaces})
      t=$(echo ${t}|${JQ_PATH} --raw-output '.[]')
      for x in ${t}
         do
         x=$(eval echo ${x})
         xfm="-t ${x} ${xfm}"
      done
   done
   exec_ants antsApplyTransforms -e 3 -d 3 \
      -i ${i}  -r    ${target} \
      -o ${o}  ${n}  ${xfm}
}
