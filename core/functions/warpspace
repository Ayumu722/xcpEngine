warpspace() {
   local a_chk a_edges d_chk d_edges e edges f_chk f_edges i k layer n node_chk nodes o objects output route source t target x xfm
   ################################################################
   # Parse inputs
   # i         Image to be warped
   # o         Output path for warped image
   # n         Interpolation scheme
   # target    Target space to warp to
   ################################################################
   i=${1}
   o=${2}
   target=( ${3//:/ } )
   if [[ -n ${target[1]} ]]
      then
      source=${target[0]}
      target=${target[1]}
   else
      target=${target[0]}
   fi
   [[ -n ${4} ]]         && n="-n ${4}"
   ################################################################
   # Determine the coordinate space of origin
   ################################################################
   if [[ ${i} == ${img} ]]
      then
      source=${space}
   elif contains ${i} "atlas:"
      then
      i=${i//atlas:/}
      source=$(   json_query  ${i}  Space    "${atlas[${cxt}]}")
      i=$(        json_query  ${i}  Map      "${atlas[${cxt}]}")
   elif ! is_image ${i}
      then
      source=$(   json_query  ${i}  Space    "${aux_imgs[${subjidx}]}")
      i=$(        json_query  ${i}  Map      "${aux_imgs[${subjidx}]}")
   elif [[ -z ${source} ]]
      then
      source=${space}
   fi
   i=$(eval echo ${i})
   echo $source; echo $target; echo $i
   ################################################################
   # Parse available spaces (nodes) and transforms (edges)
   ################################################################
   objects=$(cat  ${spaces[${subjidx}]}   |$JQ_PATH      'keys[]')
   for k    in    $objects
      do
      node_chk=$( json_query  ${k}  Map               ${spaces[${subjidx}]})
      k=${k//\"/}
      if [[       -n ${node_chk} ]]
         then
         k=${k//\%*/}
         [[ ${nodes//${k}/} == ${nodes} ]] && nodes="${nodes} ${k}"
      else
         [[ ${edges//${k}/} == ${edges} ]] && edges="${edges} ${k}" || continue
         a_chk=$( json_query  \"${k}\"  TransformANTs     ${spaces[${subjidx}]})
         f_chk=$( json_query  \"${k}\"  TransformFSL      ${spaces[${subjidx}]})
         d_chk=$( json_query  \"${k}\"  TransformDRAMMS   ${spaces[${subjidx}]})
         if [[    -n ${a_chk}    ]]
            then
            a_edges="${a_edges} ${k}"
         fi
         if [[    -n ${f_chk}    ]]
            then
            f_edges="${a_edges} ${k}"
         fi
         if [[    -n ${d_chk}    ]]
            then
            d_edges="${a_edges} ${k}"
         fi
      fi
   done
   ################################################################
   # Determine the shortest route from the source space to the
   # target space
   ################################################################
   nodes=$(echo $nodes)
   edges=$(echo $edges)
   nodes=${nodes// /,}
   edges=${edges// /,}
   echo $nodes; echo $edges
   route=( $(${XCPEDIR}/utils/warprouter.R \
      -n ${nodes} \
      -e ${edges} \
      -s ${source} \
      -t ${target//\%*/}) )
   ################################################################
   # Obtain the target reference and perform the warp
   ################################################################
   target=$(json_query \"${target}\" Map ${spaces[${subjidx}]})
   target=$(eval echo ${target})
   layer=${route[0]}
   route=( "${route[@]:1}" )
   for e in "${route[@]}"
      do
      t=$(json_query \"${e}\" TransformANTs ${spaces[${subjidx}]})
      t=$(echo ${t}|${JQ_PATH} --raw-output '.[]')
      for x in ${t}
         do
         x=$(eval echo ${x})
         xfm="-t ${x} ${xfm}"
      done
   done
   exec_ants antsApplyTransforms -e 3 -d 3 \
      -i ${i}  -r    ${target} \
      -o ${o}  ${n}  ${xfm}
}
