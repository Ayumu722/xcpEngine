#!/usr/bin/env bash

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################


###################################################################
# Р Ћ 2017
###################################################################
<< CONFIG_UI

 config_ui provides a minimal user interface for multimodal
 pipeline configuration. This is the single-modal configuration
 script for functional connectivity processing..

CONFIG_UI
###################################################################
declare  -A fc
source   ${XCPEDIR}/core/constants
source   ${XCPEDIR}/core/functions/library.sh
source   ${XCPEDIR}/core/functions/cluster_submit










###################################################################
# On script open
###################################################################
open() {

fc[confound]=36P
fc[censor]=Despike
fc[filter_hp]=0.01
fc[filter_lp]=0.08
fc[smooth]=6
fc[seed]=
fc[coreg]=Mean
fc[regress]=BP-REG
fc[remask]=False
cat << endstream
___________________________________________________________________



   Modality: functional connectivity.
   Select a menu item, or finalise your pipeline.
   


endstream

}










###################################################################
# Main menu
###################################################################
refresh_menu() {
   options=(
      
      [1]="Denoising stream                  ${fc[confound]} model"
      [2]="Censor                            ${fc[censor]}"
      [3]="Temporal filter                   ${fc[filter_hp]}-${fc[filter_lp]} Hz"
      [4]="Spatial filter                    ${fc[smooth]} mm FWHM"
      [5]="Seed-based analysis               ${fc[seed]}"
      [6]="Coregistration source             ${fc[coreg]} image"
      [7]="Regression/filtering order        ${fc[regress]}"
      [8]="Remask                            ${fc[remask]}"
     [10]="Print design"
     [11]="Trigger pipeline"
      
   )
}
menu() {

   local REPLY
   local options
   refresh_menu
   
   local response=(
      
      [1]="
····································································
      
      
Select a denoising stream.

"
      [2]="
····································································
      
      
Select a censor setting.

"
      [3]="
····································································
      
      
Specify the passband for the temporal filter.

"
      [4]="
····································································
      
      
Specify the kernel FWHM for spatial smoothing.

"
      [5]="
····································································
      
      
Add a spatial coordinates library for seed-based correlation
analysis.

"
      [6]="
····································································
      
      
Specify the functional image that should be coregistered to the
anatomical reference.

"
      [7]="
····································································
      
      
Specify whether filtering or regression should be performed first.

"
      [8]="
····································································
      
      
Specify whether the anatomical image should be used to refine the
image mask after coregistration.

"
      [0]="


Select an option by entering the associated numeral.


"
     [99]="Exiting"
      
   )
   
   local cmd=(
   
      [1]="menu_confound"
      [2]="menu_censor"
      [3]="menu_filter"
      [4]="menu_smooth"
      [5]="menu_seed"
      [6]="menu_coreg"
      [7]="menu_regress"
      [8]="menu_remask"
     [99]="exit"
   
   )
   
   while true
   
   do select option in "${options[@]}" "Exit"
   
   do case $REPLY in
   
   1 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   2 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   3 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   4 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   5 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   6 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   7 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   8 ) echo "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu; break;;
   11) echo "${response[99]}";    eval ${cmd[99]};;
   * ) echo "${response[0]}";     eval ${cmd[0]};;
   
   esac; done; done

}










###################################################################
# Confound model selection menu
###################################################################
menu_confound() {

   local REPLY
   local options=(
   
      [1]="36P"
      [2]="24P"
      [3]="ICA-AROMA"
      [4]="ICA-AROMA+GSR"
      [5]="aCompCor50"
      [6]="aCompCor50+GSR"
   
   )
   
   local response=(
   
      [1]="
····································································


${CYA}36-parameter model selected.${RCL}

Includes 6 head motion parameters, mean white matter and CSF signal,
mean global signal, 9 temporal derivatives, and 18 quadratic terms.

"
      [2]="
····································································


${CYA}24-parameter model selected.${RCL}

Includes 6 head motion parameters, 6 temporal derivatives, and 12 
quadratic terms.

"
      [3]="
····································································


${CYA}ICA-AROMA model selected.${RCL}

Includes IC signals classified as noise and mean signal from white 
matter and CSF.

"
      [4]="
····································································


${CYA}ICA-AROMA+GSR model selected.${RCL}

Includes IC signals classified as noise, mean white matter and CSF 
signal, and mean global signal.

"
      [5]="
····································································


${CYA}aCompCor50 model selected.${RCL}

Includes 6 head motion parameters and principal component signals 
from white matter and CSF sufficient to explain 50 percent of 
compartment variance.

"
      [6]="
····································································


${CYA}aCompCor50+GSR model selected.${RCL}

Includes 6 head motion parameters, mean global signal, and 
principal component signals from white matter and CSF sufficient to 
explain 50 percent of compartment variance.

"
      [0]="

····································································


Select an option by entering the associated numeral.

${CYA}DENOISING STREAM${LGR}
Subject movement introduces a substantial amount of spurious 
variance into the BOLD signal; if data processing fails to account
for the influence of motion-related variance, then artefact may
subsequently be misconstrued as effect of interest. Accordingly,
a number of high-performing processing streams for removing
motion artefact are made available:

${CYA}36-parameter model${LGR}
Includes 6 head motion parameters, mean white matter and CSF signal,
mean global signal, 9 temporal derivatives, and 18 quadratic terms.

${CYA}24-parameter model${LGR}
Includes 6 head motion parameters, 6 temporal derivatives, and 12 
quadratic terms. ${RED}Use of the 24-parameter model is strongly 
discouraged, as it has been shown to perform poorly.${RCL}

${CYA}ICA-AROMA${LGR}
Includes IC signals classified as noise and mean signal from white 
matter and CSF.

${CYA}ICA-AROMA+GSR${LGR}
Includes IC signals classified as noise, mean white matter and CSF 
signal, and mean global signal.

${CYA}aCompCor50${LGR}
Includes 6 head motion parameters and principal component signals 
from white matter and CSF sufficient to explain 50 percent of 
compartment variance.

${CYA}aCompCor50+GSR${LGR}
Includes 6 head motion parameters, mean global signal, and 
principal component signals from white matter and CSF sufficient to 
explain 50 percent of compartment variance.${RCL}

····································································
      
      
Select a denoising stream.

"
   
   )
   
   local cmd=(
   
      [1]="fc[confound]=${options[1]}"
      [2]="fc[confound]=${options[2]}"
      [3]="fc[confound]=${options[3]}"
      [4]="fc[confound]=${options[4]}"
      [5]="fc[confound]=${options[5]}"
      [6]="fc[confound]=${options[6]}"
   
   )
   
   while true
   
   do select option in "${options[@]}"
   
   do case $REPLY in
   
   1 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   2 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   3 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   4 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   5 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   6 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   * ) echo -e "${response[0]}";     eval ${cmd[0]};     break;;
   
   esac; done; done

}










###################################################################
# Framewise censoring
###################################################################
menu_censor() {

   local REPLY
   local options=(
      
      [1]="None"
      [2]="Despike"
      [3]="Censor"
      
   )
   
   local response=(
      
      [1]="
····································································


${CYA}Censoring disabled.${RCL}

No censoring or interpolation will be performed.

"
      [2]="
····································································


${CYA}Despiking enabled.${RCL}

Despiking is a spatially adaptive framewise censoring strategy
that identifies signal outliers in voxelwise data and interpolates
over those outlying values.

"
      [3]="
····································································


${CYA}Censoring enabled.${RCL}

Framewise censoring identifies volumes that are likely to be
contaminated by artefact -- for instance, those with high subject
movement -- and removes those volumes from the data.

"
      [0]="

····································································


Select an option by entering the associated numeral.

${CYA}CENSOR${LGR}
Artefactual variance can contaminate time points to such an extent
that they become dominated by noise, and the overall signal-to-
noise ratio of the data can be improved by interpolating over those 
time points or discarding them altogether. Two options for
'censoring' data in this way are made available.

${CYA}Censoring${LGR}
Framewise censoring identifies volumes that are likely to be
contaminated by artefact -- for instance, those with high subject
movement -- and removes those volumes from the data. 

We implement censoring using an iterative approach: a temporal mask 
is used to exclude motion-contaminated volumes at every stage of 
the analysis, including detrending and temporal filtering. At the 
filtering stage, we generate surrogate data with the same spectral 
character as the unflagged data. Finally, we include spike 
regressors in the final confound regression step and discard all 
flagged volumes.

Censoring settings will flag any volumes that exceed either of 
the following thresholds:
Relative RMS displacement              > 0.05 mm / s
Standardised DVARS                     > 1.5

${CYA}Despiking${LGR}
Despiking is a spatially adaptive framewise censoring strategy
that identifies signal outliers in voxelwise data and interpolates
over those outlying values. Despiking is implemented as in AFNI's
3dDespike.

${RED}Note that framewise censoring can disrupt the autocorrelation
structure inherent in the data. Thus, it may not be suitable for
applications where autocorrelation structure is important, such as
dynamic assessments of functional connectivity.${RCL}

····································································
      
      
Select a censor setting.

"
      
   )
   
   local cmd=(
   
      [1]="fc[censor]=${options[1]}"
      [2]="fc[censor]=${options[2]}"
      [3]="fc[censor]=${options[3]}"
   
   )
   
   while true
   
   do select option in "${options[@]}"
   
   do case $REPLY in
   
   1 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   2 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   3 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; return;;
   * ) echo -e "${response[0]}";     eval ${cmd[0]};     break;;
   
   esac; done; done

}










###################################################################
# Filtering
###################################################################
refresh_menu_filter() {
   options=(
   
      [1]="High-pass frequency         ${fc[filter_hp]} Hz"
      [2]="Low-pass frequency          ${fc[filter_lp]} Hz"
      [3]="Accept filter settings"
   
   )
}
menu_filter_hp() {
   local buffer
   local response=(
      [0]=
      [1]=
   )
   while true
      do
      read -p "" -e -i ${fc[filter_hp]} buffer
      if is+numeric ${buffer}
         then
         echo -e "${response[1]}"
         fc[filter_hp]=${buffer}
         return
      else
         echo -e "${response[0]}"
      fi
   done
}
menu_filter_lp() {
   local buffer
   local response=(
      [0]=
      [1]=
      [2]=
   )
   while true
      do
      read -p "" -e -i ${fc[filter_lp]} buffer
      if is+numeric ${buffer}
         then
         echo -e "${response[1]}"
         fc[filter_lp]=${buffer}
         return
      elif [[ ${buffer} == nyquist ]] \
      [[      ${buffer} == Nyquist ]] \
      [[      ${buffer} == n       ]] \
      [[      ${buffer} == N       ]]
         then
         echo -e "${response[2]}"
         fc[filter_lp]=Nyquist
         return
      else
         echo -e "${response[0]}"
      fi
   done
}
menu_filter() {

   local REPLY
   local options
   refresh_menu_filter
   
   local response=(
   
      [1]="
····································································


Specify the high-pass frequency cutoff for the temporal filter.

"
      [2]="
····································································


Specify the high-pass frequency cutoff for the temporal filter.

"
      [3]="
····································································


${CYA}Filter pass-band: ${fc[filter_hp]} - ${fc[filter_lp]} Hz${RCL}

"
      [0]="
····································································


${CYA}TEMPORAL BANDPASS FILTER${RCL}

The temporal filter removes or retains signal in the data on the 
basis of its frequency. Because both high-frequency and very-low-
frequency bands are susceptible to artefact, a 'band pass' filter
is often applied in analyses of functional connectivity. A band
pass filter retains a specified frequency band: frequencies that 
are both above the high-pass cutoff and below the low-pass cutoff
frequency. 

${CYA}Low-pass frequency cutoff${LGR}
Functional connectivity between regions of interest is typically 
determined on the basis of synchrony in low-frequency fluctuations 
(Biswal et al., 1995); therefore, removing such frequencies may 
effectively remove noise from the timeseries while retaining 
signal of interest. For a contrasting view, see Boubela et al. 
(2013).

${CYA}High-pass frequency cutoff${LGR}
High-pass filters can be used to remove very-low-frequency drift 
from an acquisition; this drift is typically attributable to 
scanner noise.

Bandpass filtering the analyte time series but not nuisance 
regressors re-introduces noise-related variance at removed 
frequencies when the time series is residualised with respect to 
the regressors via linear fit. (Our pipeline is designed so as to 
make this involuntary reintroduction of noise impossible.) Instead, 
the recommended approach is filtering both the time series and the 
nuisance regressors immediately prior to fitting and 
residualisation.

${RED}If you are computing connectivity using a wavelet coherence
approach, it is then possible that 

"
   
   )
   
   local cmd=(
   
      [1]="menu_filter_hp"
      [2]="menu_filter_lp"
      [3]="return"
   
   )
   
   while true
   
   do select option in "${options[@]}"
   
   do case $REPLY in
   
   1 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu_filter; break;;
   2 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu_filter; break;;
   3 ) echo -e "${response[REPLY]}"; eval ${cmd[REPLY]}; refresh_menu_filter; break;;
   * ) echo -e "${response[0]}";     eval ${cmd[0]};     break;;
   
   esac; done; done

}










###################################################################
# Execute
###################################################################
main() {
   open
   menu
}

main
