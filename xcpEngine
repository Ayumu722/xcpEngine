#!/usr/bin/env bash

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################


###################################################################
# Р Ћ 2015-2017
###################################################################
<< XCPENGINE

 xcpEngine is software that reads in functional connectivity
 pipelines (design files) and deploys an assortment of multimodal
 analytic tools in order to run those pipelines.

 Development team:
 Lead:         Rastko Ciric 
               rastko@mail.med.upenn.edu
 Multimodal:   Adon FG Rosen
               adrose@mail.med.upenn.edu
 PI:           Ted Satterthwaite
               sattertt@mail.med.upenn.edu
 
 What is XCP short for? Nobody knows what the X represents, but
 CP almost certainly stands for Communist Party.

 This program is free software: you can redistribute it and/or 
 modify it under the terms of the GNU General Public License as 
 published by the Free Software Foundation.

 Any third-party programs distributed with xcpEngine are
 distributed under their own licenses.

 As a courtesy, we ask that you include the following citations
 in publications that make use of this program:

 Ciric R, Wolf DH, Power JD, Roalf DR, Baum GL, Ruparel K,
    Shinohara RT, Elliott MA, Eickhoff SB, Davatzikos C, Gur RC,
    Gur RE, Bassett DS, Satterthwaite TD (in press)
    Benchmarking participant-level confound regression strategies
    for the control of motion artifact in studies of functional
    connectivity. NeuroImage.

 Dependencies:
  * FSL (available from FMRIB)
  * R and the following packages (available from CRAN)
      * ANTsR
      * pracma
      * optparse
      * signal
  * ANTs (available from GitHub)
  * AFNI (available from AFNI/NIfTI server)
  * Convert3D (available from ITK-Snap server)
  * Other packages may be required for implementation of specific
    strategies, e.g. for denoising.
 
 XCP v0.6.0 ACCELERATOR

XCPENGINE
###################################################################
source ${XCPEDIR}/core/constants

Usage(){
cat << endstream
___________________________________________________________________


   Usage: `basename $0` -d <design> <options>

   Compulsory arguments:
    -d : Primary design file for pipeline:
         Use xcpConfig for guided creation of a design
         file.

   Optional arguments:
    -m : Execution mode
         Input can either be 'c' (for execution on a computing
         cluster) or 's' (for serial execution on a single
         machine)[default]
    -t : Trace:
         If the XCP Engine is called with the -t argument,
         then all commands called by the XCP Engine will
         be traced and explicitly replicated in a log
         file. This log file can then be used to debug
         output or can be converted to a standalone
         pipeline.


endstream
}
###################################################################
# Set defaults (serial/local run)
###################################################################
mode=s
###################################################################
# Parse arguments
###################################################################
while getopts "d:m:t" OPTION
   do
   case $OPTION in
   d)
      indesign=${OPTARG}
      ;;
   m)
      mode=${OPTARG}
      ;;
   t)
      set -x
      trace_prop="-t 1"
      ;;
   *)
      echo "Option not recognised: ${OPTARG}"
      Usage
      exit
   esac
done
shift $((OPTIND-1))





###################################################################
# Validate and parse the design and cohort files.
# All pipeline variables are available after validation.
###################################################################
source ${XCPEDIR}/core/validateDesign ${indesign}
source ${XCPEDIR}/core/validateCohort ${path_cohort}





###################################################################
# Obtain a timestamp for the current deployment of the engine.
###################################################################
xcpdate=$(date +%Y%m%d%H%M)
###################################################################
# Prepare to analyse the entire pipeline.
###################################################################
analysis_remaining=${pipeline}
modules=$(echo ${pipeline}|sed s@','@' '@g)





###################################################################
# Verify that all dependencies are installed.
# Obtain version information for all general dependencies.
###################################################################
source ${XCPEDIR}/core/checkDependenciesXCP
mkdir -p ${out_group}
###################################################################
# Next, ensure that any module-specific prerequisites are
# installed.
###################################################################
modreqs="...Checking module-specific dependencies..."
for module in ${modules}
   do
   reqpath=${XCPEDIR}/modules/${module}/${module}.req
   if [[ -e ${reqpath} ]]
      then
      source ${reqpath}
   fi
done
echo "${modreqs}"
###################################################################
# Write version information to the version tracking file.
###################################################################
versions=${out}/${prefix}_logs/${xcpdate}_${prefix}_versions
if [[ ! -e ${versions} ]]
   then
   ver_XCP=" * Version XCP Engine "$(cat ${XCPEDIR}/core/version)
   echo \
      "
      ▤▥ ▤▤▥▤▤ ▤▥ DEPENDENCY/ENVIRONMENT CHECK RESULTS ▥▤ ▤▤▥▤▤ ▥▤
      ▥▤ ▤▤▥▤▤ ▥▤                                      ▤▥ ▤▤▥▤▤ ▤▥
      
      ANALYSIS: ${analysis}
      ${ver_AFNI}
      ${ver_ANTS}
      ${ver_FSL}
      ${ver_ITK}
      ${ver_R}
      ${ver_RSCRIPT}
      ${RpackageChk}
      ${ver_XCP}
       * FSLDIR=${FSLDIR}
       * ANTSPATH=${ANTSPATH}
       * XCPEDIR=${XCPEDIR}
      ${modreqs}
      " \
   >> ${versions}
fi





###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
#
# EXECUTE THE PIPELINE
#
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################
echo  -e \
"


###################################################################
#  ${RED}☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭${RCL}  #
#                                                                 #
#  ${RED}☭${RCL}                      XCP ${RED}★ ★ ★${RCL} ENGINE                     ${RED}☭${RCL}  #
#                                                                 #
#  ${RED}☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭${RCL}  #
###################################################################


"
modHead='


###################################################################
#  ${RED}☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭${RCL}  #
#                                                                 #
                  CURRENTLY PROCESSING MODULE:                     
                         ${RED}★${RCL} ${module} ${RED}★${RCL}                             
#                                                                 #
#  ${RED}☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭${RCL}  #
###################################################################
'
logHead='

###################################################################
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
#                                                                 #
#  ☭                         PIPELINE                          ☭  #
#                                                                 #
#  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  #
###################################################################


 * Executing in cluster mode.
'





###################################################################
# Run the XCP Localiser first.
###################################################################
subjidx=9001
unset ids
module=LOCALISER
echo "$(eval "echo -e \"${modHead}\"")"
for subject in ${cohort}
   do
   ################################################################
   # Parse subject identifiers, then re-parse the design to
   # evaluate subject-specific variables.
   ################################################################
   source ${XCPEDIR}/core/parseSubject ${subject}
   source ${design}
   [[ ! -d ${out}/${prefix}_logs/ ]] && mkdir -p ${out}/${prefix}_logs
   ################################################################
   # Run the localiser.
   ################################################################
   case ${mode} in
   s)
      ${XCPEDIR}/xcpLocaliser \
         -d ${design} \
         -s ${subjidx} \
         ${trace_prop}
      ;;
   c)
      #############################################################
      # Initialise the subject's processing log.
      #############################################################
      logfile=${out}/${prefix}_logs/${analysis}_${xcpdate}_${prefix}_log
      echo "${logHead}" >> ${logfile}
      #############################################################
      # Submit.
      #############################################################
      id=$(qsub \
            -V \
            -S /bin/bash \
            -cwd \
            -j y \
            -o ${logfile} \
            ${cspec} \
         ${XCPEDIR}/xcpLocaliser \
            -d ${design} \
            -s ${subjidx} \
            ${trace_prop})
      id=$(echo ${id}|cut -d' ' -f3)
      ids="${ids} -e ${id}"
      ;;
   esac
   (( subjidx++ ))
done
###################################################################
# Wait for the localiser to run to completion.
###################################################################
if [[ ${mode} == c ]]
   then
   sleep 5
   ${XCPEDIR}/utils/qstatus ${ids}
fi





###################################################################
# Then, iterate through all modules.
###################################################################
cxt=1
for module in ${modules}
   do
   echo "$(eval "echo -e \"${modHead}\"")"
   ################################################################
   # Obtain paths to the subject- and group-level scripts for
   # the current module, if each exists.
   ################################################################
   modS=$(ls -d1 ${XCPEDIR}/modules/${module}/${module}.mod 2>/dev/null)
   modG=$(ls -d1 ${XCPEDIR}/modules/${module}/${module}.g.mod 2>/dev/null)
   ################################################################
   # SUBJECT-LEVEL PROCESSING
   #---------------------------------------------------------------
   # If the current module has a subject-level component, then
   # iterate through all subjects and run it.
   ################################################################
   if [[ -n ${modS} ]]
   then
   unset ids
   subjidx=9001
   for subject in ${cohort}
      do
      #############################################################
      # Parse subject identifiers, then re-parse the design to
      # evaluate subject-specific variables.
      #############################################################
      subjid=$subject
      source ${XCPEDIR}/core/parseSubject ${subject}
      source ${design}
      logfile=${out}/${prefix}_logs/${analysis}_${xcpdate}_${prefix}_log
      #############################################################
      # Before running the subject, verify that it has not yielded
      # erroneous output or been labelled for exclusion for quality
      # reasons.
      #############################################################
      errortest=""
      [[ -e ${logfile} ]] && errortest=$(grep -i XCP-ERROR ${logfile})
      qatest=""
      [[ -e ${logfile} ]] && qatest=$(grep -i QA-EXCLUDE ${logfile})
      if [[ ! -z ${errortest} ]] || [[ ! -z ${qatest} ]]
         then
         echo " Skipping analysis for:"
         echo " * ${subjid}"
         echo " for the following reasons."
         echo "${errortest}"
         echo "${qatest}"
         continue
      fi
      #############################################################
      # Parse the subject-specific design file.
      #############################################################
      design_local=${out}/${prefix}.dsn
      source ${design_local}
      #############################################################
      # Execute the current module.
      #############################################################
      case ${mode} in
      s)
         ${modS} -d ${design_local} -c ${cxt} ${trace_prop}
         ;;
      c)
         id=$(qsub -V -S /bin/bash -cwd -j y -o ${logfile} ${cspec} \
            ${modS} -d ${design_local} -c ${cxt} ${trace_prop})
         id=$(echo ${id}|cut -d' ' -f3)
         ids="${ids} -e ${id}"
         ;;
      esac
      (( subjidx++ ))
   done
   ################################################################
   # Wait for all subject-level routines to run to completion.
   ################################################################
   if [[ ${mode} == c ]]
      then
      sleep 5
      ${XCPEDIR}/utils/qstatus ${ids}
   fi
   fi
   ################################################################
   # GROUP-LEVEL PROCESSING
   #---------------------------------------------------------------
   # If the current module has a group-level component, then
   # execute it.
   ################################################################
   if [[ -n ${modG} ]]
   then
   [[ ${glog} != 1 ]] && rm -f ${out_group}/log/${analysis}_log
   [[ ! -e ${out_group}/log ]] && mkdir -p ${out_group}/log && glog=1
   [[ ! -e ${out_group}/${analysis}.dsn ]] \
      && cp ${design} ${out_group}/${analysis}.dsn
   logfile=${out_group}/log/${analysis}_log
   design_local=${out_group}/${analysis}.dsn
   case ${mode} in
   s)
      ${modG} -d ${design_local} -c ${cxt} ${trace_prop}
      ;;
   c)
      id=$(qsub -V -S /bin/bash -cwd -j y -o ${logfile} ${cspec} \
         ${modG} -d ${design_local} -c ${cxt} ${trace_prop})
      id=$(echo ${id}|cut -d' ' -f3)
      sleep 5
      ${XCPEDIR}/utils/qstatus -e ${id}
      ;;
   esac
   fi
   ################################################################
   # Advance the pipeline to the next context.
   ################################################################
   (( cxt++ ))
done





###################################################################
# Conclude the analysis.
###################################################################
echo  -e \
"


###################################################################
#  ${RED}☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭${RCL}  #
#                                                                 #
#  ${RED}☭${RCL}                     ANALYSIS COMPLETE                     ${RED}☭${RCL}  #
#                                                                 #
#  ${RED}☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭  ☭${RCL}  #
###################################################################
"
